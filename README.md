# miniconfig

A minimalistic config file crate written in Rust.

## Overview

- **Keys**

    Any valid UTF-8 string, with special characters escaped.

    These are the special characters which must be escaped:

    - `\`
    - `'`
    - `"`
    - `\0`
    - `\a`
    - `\b`
    - `\t`
    - `\n`
    - `\v`
    - `\f`
    - `\r`

    In Lua configs (requires `"lua"` feature), keys work according to Lua rules: keys which are not valid Lua identifiers (i.e. do not contain only from ASCII alphanumerical characters and underscores and start with an ASCII alphabetical character) must be enclosed in brackets and quotes (e.g. `["áéíóú"]`). Unicode 2-digit hexadecimal escape sequences work according to Lua rules.

    In INI configs (requires `"ini"` feature), additionally, special INI characters must be escaped. These are the special INI characters:

    - `[` (section start delimiter)
    - `]` (section end delimiter)
    - `;` (default comment delimiter)
    - `#` (optional comment delimiter)
    - `=` (default key-value separator)
    - `:` (optional key-value separator)

    Space (`' '`) must be escaped in key and section name strings.

- **Values**

    Same rules as keys.

    In Lua configs (requires `"lua"` feature) string values are always quoted.

    In INI configs (requires `"ini"` feature) quoted string values may contain spaces; unquoted string values must escape spaces.

- **Lua configs** (requires `"lua"` feature).

    Main format for human-readable config files with nested array/table support.

    Piggybacks on the Lua interpreter both as a parser and as runtime data representation.

    May be used directly as a Lua representation within an `rlua` `Context`, or be serialized for dynamic or read-only use to decouple itself from the Lua state.

    **Data**: text file representing a(n incomplete) Lua script, declaring a root config table with string keys, including nested config arrays/tables represented by Lua tables. Only a subset of Lua types / features are supported.

    **Runtime**: internally represented by a root Lua table reference. Provides a mutable config interface. Can add/modify/remove values.

    **Serialization**: to string Lua script, to binary config (requires `"bin"` feature), to string INI config (requires `"ini"` feature, does not support arrays / nested tables).

    **Example**:

    ``` lua
    {
        array_value = { 54, 12, 78.9 }, -- array_value
        bool_value = true,
        float_value = 3.14,
        int_value = 7,
        string_value = "foo",
        table_value = {
            bar = 2020,
            baz = "hello",
            foo = false,
        }, -- table_value
    }
    ```

    **Use cases**: use Lua config source text files for human-readable / writable / mergeable / diff-able data of arbitrary complexity that frequently changes during development, but does not need to / must not be user-visible.

- **Dynamic configs** (requires `"dyn"` feature).

    Main format for runtime representation of dynamic configs, or an intermediate representation for Lua configs (after deserialization) / binary configs (before serialization).

    **Data**: if `"ini"` feature is enabled - a text file representing a valid `.ini` config, declaring a root config table with string keys and a number of sections - nested tables. Unquoted values, if allowed, are parsed as booleans / integers / floats / strings, in order. Quoted values, if enabled, are always treated as strings.

    **Runtime**: internally represented by a root hashmap with string keys. Provides a mutable config interface. Can add/modify/remove values.

    **Serialization**: to string Lua script (requires `"lua"` feature), to binary config (requires `"bin"` feature), to string INI config (requires `"ini"` feature, does not support arrays / nested tables).

    **Use cases**: if `"ini"` feature is enabled - use .ini config source text files for human-readable / writable data of limited complexity (only one level of nested tables, no arrays) which must be user-visible.

- **Binary configs** (requires `"bin"` feature).

    Main format for runtime representation of read-only configs with nested array/table support.

    **Data**: raw byte blob. Generated by serializing a Lua config (requires `"lua"` feature), dynamic config (requires `"dyn"` feature), or by using the provided writer API.

    **Runtime**: wrapper over the raw byte blob. Provides a read-only config interface. Cannot add/modify/remove values.

    **Serialization**: to string Lua script (requires `"lua"` feature), to string INI config (requires `"ini"` feature, does not support arrays / nested tables).

    **Use cases**: use for read-only data of arbitrary complexity which must not be user-visible, or for caching of data which does not need to change frequently at runtime for loading / access performance.

## Example

See `example.rs`.

## Building

Requires some path dependencies in the parent directory - see `Dependencies` section.

## Features

- `"lua"` (enabled by default) - adds support for Lua configs.
- `"dyn"` (enabled by default) - adds support for dynamic configs.
- `"bin"` (enabled by default) - adds support for binary configs, serialization of Lua/dynamic configs to binary configs.
- `"ini"` (requires `"dyn"` feature, enabled by default) - adds support for parsing INI config strings to dynamic configs, serialization of Lua/dynamic/binary configs to INI config strings.

## Dependencies

- If "lua" feature is enabled (it is by default), [`rlua`](https://crates.io/crates/rlua) and [`rlua_ext`](https://github.com/alex05447/rlua_ext) as a path dependency (TODO - github dependency?).

- If "ini" feature is enabled, [`bitflags`](https://crates.io/crates/bitflags) for INI parser options.

## Problems / missing features

Despite the fact that all configs implement a common interface, it is currently impossible to implement a Rust trait to encapsulate that
due to Rust not having GAT's (generic associated types) at the moment of writing.

As a result, some code is duplicated internally in the crate, and the crate users will not be able to write code generic over config implementations.
